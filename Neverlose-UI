local Library = {}

local NeverloseVersion = "v1.1A."

local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local StarterGui = game:GetService("StarterGui")
local RunService = game:GetService("RunService")

-- Get the local player's mouse for legacy reasons, though UserInputService is preferred for modern input
local themouse = Players.LocalPlayer:GetMouse()

-- Destroy existing UI with the same name to prevent duplicates
for i,v in next, game.CoreGui:GetChildren() do
    if v:IsA("ScreenGui") and v.Name == "Neverlose" then
        v:Destroy()
    end
end

-- Helper to send notifications
local function Notify(title, text)
    StarterGui:SetCore("SendNotification", {
        Title = title,
        Text = text,
        Duration = 5
    })
end

-- Updated Dragify function to support both mouse and touch input
local function Dragify(frame, parent)
    parent = parent or frame

    local dragging = false
    local dragInput
    local startMousePosition
    local startFramePosition

    frame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            startMousePosition = input.Position
            startFramePosition = parent.Position

            local inputChangedConnection
            inputChangedConnection = input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                    if inputChangedConnection then
                        inputChangedConnection:Disconnect()
                    end
                end
            end)
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            local delta = input.Position - startMousePosition
            parent.Position = UDim2.new(startFramePosition.X.Scale, startFramePosition.X.Offset + delta.X, startFramePosition.Y.Scale, startFramePosition.Y.Offset + delta.Y)
        end
    end)
end

-- Round function (no change needed for mobile)
local function round(num, bracket)
    bracket = bracket or 1
    local a = math.floor(num/bracket + (math.sign(num) * 0.5)) * bracket
    if a < 0 then
        a = a + bracket
    end
    return a
end

-- Button effect (no major changes needed, as it relies on MouseEnter/Leave which works with touch for simple hover effects)
local function buttoneffect(options)
    pcall(function()
        options.entered.MouseEnter:Connect(function()
            if options.frame.TextColor3 ~= Color3.fromRGB(234, 239, 246) then
                TweenService:Create(options.frame, TweenInfo.new(0.06, Enum.EasingStyle.Quart, Enum.EasingDirection.In), {
                    TextColor3 = Color3.fromRGB(234, 239, 245)
                }):Play()
            end
        end)
        options.entered.MouseLeave:Connect(function()
            if options.frame.TextColor3 ~= Color3.fromRGB(157, 171, 182) and options.frame.TextColor3 ~= Color3.fromRGB(234, 239, 246) then
                TweenService:Create(options.frame, TweenInfo.new(0.06, Enum.EasingStyle.Quart, Enum.EasingDirection.In), {
                    TextColor3 = Color3.fromRGB(157, 171, 182)
                }):Play()
            end
        end)
    end)
end

-- Click effect (no major changes needed, as it's visual)
local function clickEffect(options)
    options.button.MouseButton1Click:Connect(function()
        local new = options.button.TextSize - tonumber(options.amount)
        local revert = new + tonumber(options.amount)
        TweenService:Create(options.button, TweenInfo.new(0.15, Enum.EasingStyle.Elastic, Enum.EasingDirection.Out), {TextSize = new}):Play()
        task.wait(0.1) -- Using task.wait instead of wait
        TweenService:Create(options.button, TweenInfo.new(0.1, Enum.EasingStyle.Elastic, Enum.EasingDirection.Out), {TextSize = revert}):Play()
    end)
end

function Library:Toggle(value)
    -- Corrected GetServer to GetService
    if game:GetService("CoreGui"):FindFirstChild("Neverlose") == nil then return end
    local enabled = (type(value) == "boolean" and value) or game:GetService("CoreGui"):FindFirstChild("Neverlose").Enabled
    game:GetService("CoreGui"):FindFirstChild("Neverlose").Enabled = not enabled
end

function Library:Window(options)
    options.text = options.text or "NEVERLOSE"

    local SG = Instance.new("ScreenGui")
    local Body = Instance.new("Frame")
    Dragify(Body, Body)
    local bodyCorner = Instance.new("UICorner")

    local SideBar = Instance.new("Frame")
    local sidebarCorner = Instance.new("UICorner")
    local sbLine = Instance.new("Frame")

    local TopBar = Instance.new("Frame")
    local tbLine = Instance.new("Frame")
    local Title = Instance.new("TextLabel")

    local allPages = Instance.new("Frame")
    local tabContainer = Instance.new("Frame")

    SG.Parent = game.CoreGui
    SG.Name = "Neverlose"
    SG.ResetOnSpawn = false -- Crucial for persistent UI across respawns

    Body.Name = "Body"
    Body.Parent = SG
    Body.AnchorPoint = Vector2.new(0.5, 0.5)
    Body.BackgroundColor3 = Color3.fromRGB(9, 8, 13)
    Body.BorderSizePixel = 0
    -- Position in center of screen with scale
    Body.Position = UDim2.new(0.5, 0, 0.5, 0)
    -- Use scale for size, ensure it's not too large on mobile
    Body.Size = UDim2.new(0.9, 0, 0.8, 0) -- 90% width, 80% height of screen

    bodyCorner.CornerRadius = UDim.new(0, 4)
    bodyCorner.Name = "bodyCorner"
    bodyCorner.Parent = Body

    SideBar.Name = "SideBar"
    SideBar.Parent = Body
    SideBar.BackgroundColor3 = Color3.fromRGB(26, 36, 48)
    SideBar.BorderSizePixel = 0
    -- Scale width relative to Body, full height
    SideBar.Size = UDim2.new(0.3, 0, 1, 0) -- 30% width of Body, full height

    sidebarCorner.CornerRadius = UDim.new(0, 4)
    sidebarCorner.Name = "sidebarCorner"
    sidebarCorner.Parent = SideBar

    sbLine.Name = "sbLine"
    sbLine.Parent = SideBar
    sbLine.BackgroundColor3 = Color3.fromRGB(15, 23, 36)
    sbLine.BorderSizePixel = 0
    -- Position at the right edge of SideBar, 1 pixel wide
    sbLine.Position = UDim2.new(1, -1, 0, 0)
    sbLine.Size = UDim2.new(0, 1, 1, 0) -- 1 pixel wide, full height

    TopBar.Name = "TopBar"
    TopBar.Parent = Body
    TopBar.BackgroundColor3 = Color3.fromRGB(9, 8, 13)
    TopBar.BackgroundTransparency = 1.000
    TopBar.BorderColor3 = Color3.fromRGB(14, 21, 32)
    TopBar.BorderSizePixel = 0
    -- Position to the right of SideBar, full width of remaining space, fixed height
    TopBar.Position = UDim2.new(SideBar.Size.X.Scale, SideBar.Size.X.Offset, 0, 0)
    TopBar.Size = UDim2.new(1 - SideBar.Size.X.Scale, -SideBar.Size.X.Offset, 0, 49) -- Remaining width, fixed height

    tbLine.Name = "tbLine"
    tbLine.Parent = TopBar
    tbLine.BackgroundColor3 = Color3.fromRGB(15, 23, 36)
    tbLine.BorderSizePixel = 0
    -- Position at the bottom of TopBar
    tbLine.Position = UDim2.new(0, 0, 1, -3) -- Aligned to bottom, 3 pixels up
    tbLine.Size = UDim2.new(1, 0, 0, 3) -- Full width, 3 pixels high

    Title.Name = "Title"
    Title.Parent = SideBar
    Title.BackgroundColor3 = Color3.fromRGB(234, 239, 245)
    Title.BackgroundTransparency = 1.000
    Title.BorderSizePixel = 0
    -- Centered horizontally, scaled size
    Title.Position = UDim2.new(0.5, 0, 0.02, 0)
    Title.AnchorPoint = Vector2.new(0.5, 0)
    Title.Size = UDim2.new(0.9, 0, 0.05, 0) -- 90% width of sidebar, 5% height
    Title.Font = Enum.Font.ArialBold
    Title.Text = options.text
    Title.TextColor3 = Color3.fromRGB(234, 239, 245)
    Title.TextSize = 28.000 -- Consider using TextScaled for title
    Title.TextWrapped = true
    Title.TextScaled = true -- Make text scale with the label size
    Title.MinTextSize = 18 -- Minimum text size to prevent it from becoming too small

    allPages.Name = "allPages"
    allPages.Parent = Body
    allPages.BackgroundColor3 = Color3.fromRGB(234, 239, 245)
    allPages.BackgroundTransparency = 1.000
    allPages.BorderSizePixel = 0
    -- Position to the right of SideBar and below TopBar, scaled
    allPages.Position = UDim2.new(SideBar.Size.X.Scale, SideBar.Size.X.Offset, TopBar.Size.Y.Scale, TopBar.Size.Y.Offset)
    allPages.Size = UDim2.new(1 - SideBar.Size.X.Scale, -SideBar.Size.X.Offset, 1 - TopBar.Size.Y.Scale, -TopBar.Size.Y.Offset)

    tabContainer.Name = "tabContainer"
    tabContainer.Parent = SideBar
    tabContainer.BackgroundColor3 = Color3.fromRGB(234, 239, 245)
    tabContainer.BackgroundTransparency = 1.000
    tabContainer.BorderSizePixel = 0
    -- Position below the title, full remaining height
    tabContainer.Position = UDim2.new(0, 0, Title.Position.Y.Scale + Title.Size.Y.Scale, 0)
    tabContainer.Size = UDim2.new(1, 0, 1 - (Title.Position.Y.Scale + Title.Size.Y.Scale), 0)

    local tabsections = {}

    function tabsections:TabSection(options)
        options.text = options.text or "Tab Section"

        local tabLayout = Instance.new("UIListLayout")
        local tabSection = Instance.new("Frame")
        local tabSectionLabel = Instance.new("TextLabel")
        local tabSectionLayout = Instance.new("UIListLayout")

        tabLayout.Name = "tabLayout"
        tabLayout.Parent = tabContainer
        tabLayout.FillDirection = Enum.FillDirection.Vertical
        tabLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
        tabLayout.Padding = UDim.new(0.01, 0) -- Small scale padding

        tabSection.Name = "tabSection"
        tabSection.Parent = tabContainer
        tabSection.BackgroundColor3 = Color3.fromRGB(234, 239, 245)
        tabSection.BackgroundTransparency = 1.000
        tabSection.BorderSizePixel = 0
        -- Full width of tabContainer, scaled height for initial
        tabSection.Size = UDim2.new(1, 0, 0, 22) -- Initial offset height, will be resized

        local function ResizeTS(num)
            tabSection.Size += UDim2.new(0, 0, 0, num) -- Still using offset for this resize for now, as it's internal
        end

        tabSectionLabel.Name = "tabSectionLabel"
        tabSectionLabel.Parent = tabSection
        tabSectionLabel.BackgroundColor3 = Color3.fromRGB(234, 239, 245)
        tabSectionLabel.BackgroundTransparency = 1.000
        tabSectionLabel.BorderSizePixel = 0
        tabSectionLabel.Size = UDim2.new(1, 0, 1, 0) -- Full size of tabSection
        tabSectionLabel.Font = Enum.Font.Gotham
        tabSectionLabel.Text = "  ".. options.text -- Adjust spacing
        tabSectionLabel.TextColor3 = Color3.fromRGB(79, 107, 126)
        tabSectionLabel.TextSize = 17.000
        tabSectionLabel.TextXAlignment = Enum.TextXAlignment.Left
        tabSectionLabel.TextScaled = true -- Enable text scaling
        tabSectionLabel.MinTextSize = 10 -- Minimum text size

        tabSectionLayout.Name = "tabSectionLayout"
        tabSectionLayout.Parent = tabSection
        tabSectionLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
        tabSectionLayout.SortOrder = Enum.SortOrder.LayoutOrder
        tabSectionLayout.Padding = UDim.new(0, 7) -- Small offset padding for consistency

        local tabs = {}

        function tabs:Tab(options)
            options.text = options.text or "New Tab"
            options.icon = options.icon or "rbxassetid://7999345313"

            local tabButton = Instance.new("TextButton")
            local tabButtonCorner = Instance.new("UICorner")
            local tabIcon = Instance.new("ImageLabel")

            local newPage = Instance.new("ScrollingFrame")
            local pageLayout = Instance.new("UIGridLayout")

            tabButton.Name = "tabButton"
            tabButton.Parent = tabSection
            tabButton.BackgroundColor3 = Color3.fromRGB(13, 57, 84)
            tabButton.BorderSizePixel = 0
            tabButton.Position = UDim2.new(0.07, 0, 0, 0) -- Position within section, UIGridLayout handles vertical
            tabButton.Size = UDim2.new(0.85, 0, 0, 40) -- 85% width of parent, fixed height (larger for touch)
            tabButton.AutoButtonColor = false
            tabButton.Font = Enum.Font.GothamSemibold
            tabButton.Text = "    " .. options.text -- Adjust spacing
            tabButton.TextColor3 = Color3.fromRGB(234, 239, 245)
            tabButton.TextSize = 14.000
            tabButton.BackgroundTransparency = 1
            tabButton.TextXAlignment = Enum.TextXAlignment.Left
            tabButton.TextScaled = true -- Enable text scaling
            tabButton.MinTextSize = 12 -- Minimum text size
            tabButton.MouseButton1Click:Connect(function()
                for i,v in next, allPages:GetChildren() do
                    v.Visible = false
                end

                newPage.Visible = true

                for i,v in next, SideBar:GetDescendants() do
                    if v:IsA("TextButton") and v.Name == "tabButton" then -- Only target tabButtons
                        TweenService:Create(v, TweenInfo.new(0.06, Enum.EasingStyle.Quart, Enum.EasingDirection.In), {
                            BackgroundTransparency = 1
                        }):Play()
                    end
                end

                TweenService:Create(tabButton, TweenInfo.new(0.06, Enum.EasingStyle.Quart, Enum.EasingDirection.In), {
                    BackgroundTransparency = 0
                }):Play()
            end)

            tabButtonCorner.CornerRadius = UDim.new(0, 4)
            tabButtonCorner.Name = "tabButtonCorner"
            tabButtonCorner.Parent = tabButton

            tabIcon.Name = "tabIcon"
            tabIcon.Parent = tabButton
            tabIcon.BackgroundColor3 = Color3.fromRGB(234, 239, 245)
            tabIcon.BackgroundTransparency = 1.000
            tabIcon.BorderSizePixel = 0
            -- Scale position and size within the button
            tabIcon.Position = UDim2.new(0.04, 0, 0.2, 0) -- 4% from left, 20% from top
            tabIcon.Size = UDim2.new(0, 24, 0, 24) -- Fixed icon size (can be scaled too if needed)
            tabIcon.Image = options.icon
            tabIcon.ImageColor3 = Color3.fromRGB(43, 154, 198)

            newPage.Name = "newPage"
            newPage.Parent = allPages
            newPage.Visible = false
            newPage.BackgroundColor3 = Color3.fromRGB(234, 239, 245)
            newPage.BackgroundTransparency = 1.000
            newPage.BorderSizePixel = 0
            newPage.ClipsDescendants = false
            -- Full size of allPages with slight padding
            newPage.Position = UDim2.new(0.01, 0, 0.01, 0)
            newPage.Size = UDim2.new(0.98, 0, 0.98, 0)
            newPage.ScrollBarThickness = 4
            newPage.CanvasSize = UDim2.new(0,0,0,0)

            pageLayout.Name = "pageLayout"
            pageLayout.Parent = newPage
            pageLayout.SortOrder = Enum.SortOrder.LayoutOrder
            -- Use scale for cell padding and cell size to make elements responsive
            pageLayout.CellPadding = UDim2.new(0.02, 0, 0.02, 0) -- 2% of parent size padding
            pageLayout.CellSize = UDim2.new(0.48, 0, 0.2, 0) -- 48% width (two columns), 20% height (flexible)
            pageLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
                newPage.CanvasSize = UDim2.new(0,0,0,pageLayout.AbsoluteContentSize.Y)
            end)

            -- Resize the TabSection height to accommodate the new tab.
            -- This still uses offset, which might be a minor issue for extreme scaling,
            -- but for adding elements with UILlListLayout, offset height can be acceptable here.
            ResizeTS(45) -- Increased size for larger touch target

            local sections = {}

            function sections:Section(options)
                options.text = options.text or "Section"

                local sectionFrame = Instance.new("Frame")
                local sectionLabel = Instance.new("TextLabel")
                local sectionFrameCorner = Instance.new("UICorner")
                local sectionLayout = Instance.new("UIListLayout")
                local sLine = Instance.new("TextLabel")
                local sectionSizeConstraint = Instance.new("UISizeConstraint")

                sectionFrame.Name = "sectionFrame"
                sectionFrame.Parent = newPage
                sectionFrame.BackgroundColor3 = Color3.fromRGB(0, 15, 30)
                sectionFrame.BorderSizePixel = 0
                -- UIGridLayout handles position, set size for grid
                sectionFrame.Size = UDim2.new(0.48, 0, 0.2, 0) -- This will be overridden by CellSize in pageLayout
                -- Ensure size constraint is set to a reasonable minimum for mobile
                sectionSizeConstraint.MinSize = Vector2.new(newPage.AbsoluteSize.X * 0.48, 100) -- Example: min 100px height

                sectionFrameCorner.CornerRadius = UDim.new(0, 4)
                sectionFrameCorner.Name = "sectionFrameCorner"
                sectionFrameCorner.Parent = sectionFrame

                sectionLabel.Name = "sectionLabel"
                sectionLabel.Parent = sectionFrame
                sectionLabel.BackgroundColor3 = Color3.fromRGB(234, 239, 245)
                sectionLabel.BackgroundTransparency = 1.000
                sectionLabel.BorderSizePixel = 0
                sectionLabel.Position = UDim2.new(0, 0, 0, 0)
                sectionLabel.Size = UDim2.new(1, 0, 0.2, 0) -- 20% of sectionFrame height for label
                sectionLabel.Font = Enum.Font.GothamSemibold
                sectionLabel.Text = "  " .. options.text
                sectionLabel.TextColor3 = Color3.fromRGB(234, 239, 245)
                sectionLabel.TextSize = 14.000
                sectionLabel.TextXAlignment = Enum.TextXAlignment.Left
                sectionLabel.TextScaled = true -- Enable text scaling
                sectionLabel.MinTextSize = 10

                sectionLayout.Name = "sectionLayout"
                sectionLayout.Parent = sectionFrame
                sectionLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
                sectionLayout.SortOrder = Enum.SortOrder.LayoutOrder
                sectionLayout.Padding = UDim.new(0, 2) -- Small offset padding

                sLine.Name = "sLine"
                sLine.Parent = sectionFrame
                sLine.BackgroundColor3 = Color3.fromRGB(13, 28, 44)
                sLine.BorderSizePixel = 0
                sLine.Position = UDim2.new(0, 0, sectionLabel.Size.Y.Scale, 0) -- Position below label
                sLine.Size = UDim2.new(1, 0, 0, 3) -- Full width, 3 pixels high
                sLine.Font = Enum.Font.SourceSans
                sLine.Text = ""
                sLine.TextColor3 = Color3.fromRGB(0, 0, 0)
                sLine.TextSize = 0

                sectionSizeConstraint.Name = "sectionSizeConstraint"
                sectionSizeConstraint.Parent = sectionFrame
                -- MinSize should ideally be relative to parent or calculated based on content
                -- For now, keep it fixed, but be aware of how this affects layout on very small screens.
                -- A better approach might be to have a minimum content height driven by children.
                sectionSizeConstraint.MinSize = Vector2.new(0, 35) -- Minimum fixed height

                local function Resize(num)
                    -- For UIListLayout within a section, this kind of offset resize is generally okay
                    -- as the section's overall height will expand.
                    sectionSizeConstraint.MinSize += Vector2.new(0, num)
                end

                local elements = {}

                function elements:Button(options)
                    if not options.text or not options.callback then Notify("Button", "Missing arguments!") return end

                    local TextButton = Instance.new("TextButton")

                    TextButton.Parent = sectionFrame
                    TextButton.BackgroundColor3 = Color3.fromRGB(13, 57, 84)
                    TextButton.BorderSizePixel = 0
                    TextButton.Size = UDim2.new(0.9, 0, 0, 35) -- 90% width of parent, fixed height (larger for touch)
                    TextButton.AutoButtonColor = false
                    TextButton.Text = options.text
                    TextButton.Font = Enum.Font.Gotham
                    TextButton.TextColor3 = Color3.fromRGB(157, 171, 182)
                    TextButton.TextSize = 14.000
                    TextButton.BackgroundTransparency = 1
                    TextButton.TextScaled = true -- Enable text scaling
                    TextButton.MinTextSize = 12
                    buttoneffect({frame = TextButton, entered = TextButton})
                    clickEffect({button = TextButton, amount = 5})
                    TextButton.MouseButton1Click:Connect(function()
                        options.callback()
                    end)

                    Resize(38) -- Adjust resize amount for new button size
                end

                function elements:Toggle(options)
                    if not options.text or not options.callback then Notify("Toggle", "Missing arguments!") return end

                    local toggleLabel = Instance.new("TextLabel")
                    local toggleFrame = Instance.new("TextButton")
                    local togFrameCorner = Instance.new("UICorner")
                    local toggleButton = Instance.new("TextButton")
                    local togBtnCorner = Instance.new("UICorner")

                    local State = options.state or false

                    if options.state then
                        toggleButton.Position = UDim2.new(0.74, 0, 0.5, 0)
                        toggleLabel.TextColor3 = Color3.fromRGB(234, 239, 246)
                        toggleButton.BackgroundColor3 = Color3.fromRGB(2, 162, 243)
                        toggleFrame.BackgroundColor3 = Color3.fromRGB(2, 23, 49)
                    end

                    toggleLabel.Name = "toggleLabel"
                    toggleLabel.Parent = sectionFrame
                    toggleLabel.BackgroundColor3 = Color3.fromRGB(157, 171, 182)
                    toggleLabel.BackgroundTransparency = 1.000
                    toggleLabel.Size = UDim2.new(0.9, 0, 0, 35) -- 90% width, fixed height (larger for touch)
                    toggleLabel.Font = Enum.Font.Gotham
                    toggleLabel.Text = " " .. options.text
                    toggleLabel.TextColor3 = Color3.fromRGB(157, 171, 182)
                    toggleLabel.TextSize = 14.000
                    toggleLabel.TextXAlignment = Enum.TextXAlignment.Left
                    toggleLabel.TextScaled = true -- Enable text scaling
                    toggleLabel.MinTextSize = 12
                    buttoneffect({frame = toggleLabel, entered = toggleLabel})

                    local function PerformToggle()
                        State = not State
                        options.callback(State)
                        TweenService:Create(toggleButton, TweenInfo.new(0.2, Enum.EasingStyle.Quart, Enum.EasingDirection.InOut), {
                            Position = State and UDim2.new(0.74, 0, 0.5, 0) or UDim2.new(0.25, 0, 0.5, 0)
                        }):Play()
                        TweenService:Create(toggleLabel, TweenInfo.new(0.06, Enum.EasingStyle.Quart, Enum.EasingDirection.InOut), {
                            TextColor3 = State and Color3.fromRGB(234, 239, 246) or Color3.fromRGB(157, 171, 182)
                        }):Play()
                        TweenService:Create(toggleButton, TweenInfo.new(0.06, Enum.EasingStyle.Quart, Enum.EasingDirection.InOut), {
                            BackgroundColor3 = State and Color3.fromRGB(2, 162, 243) or Color3.fromRGB(77, 77, 77)
                        }):Play()
                        TweenService:Create(toggleFrame, TweenInfo.new(0.06, Enum.EasingStyle.Quart, Enum.EasingDirection.InOut), {
                            BackgroundColor3 = State and Color3.fromRGB(2, 23, 49) or Color3.fromRGB(4, 4, 11)
                        }):Play()
                    end

                    toggleFrame.Name = "toggleFrame"
                    toggleFrame.Parent = toggleLabel
                    toggleFrame.BackgroundColor3 = Color3.fromRGB(4, 4, 11)
                    toggleFrame.BorderSizePixel = 0
                    toggleFrame.AnchorPoint = Vector2.new(0.5, 0.5)
                    toggleFrame.Position = UDim2.new(0.9, 0, 0.5, 0) -- Position relative to toggleLabel
                    toggleFrame.Size = UDim2.new(0, 48, 0, 24) -- Larger for touch
                    toggleFrame.AutoButtonColor = false
                    toggleFrame.Font = Enum.Font.SourceSans
                    toggleFrame.Text = ""
                    toggleFrame.TextColor3 = Color3.fromRGB(0, 0, 0)
                    toggleFrame.TextSize = 14.000
                    toggleFrame.MouseButton1Click:Connect(function()
                        PerformToggle()
                    end)

                    togFrameCorner.CornerRadius = UDim.new(0, 50)
                    togFrameCorner.Name = "togFrameCorner"
                    togFrameCorner.Parent = toggleFrame

                    toggleButton.Name = "toggleButton"
                    toggleButton.Parent = toggleFrame
                    toggleButton.BackgroundColor3 = Color3.fromRGB(77, 77, 77)
                    toggleButton.BorderSizePixel = 0
                    toggleButton.AnchorPoint = Vector2.new(0.5, 0.5)
                    toggleButton.Position = UDim2.new(0.25, 0, 0.5, 0)
                    toggleButton.Size = UDim2.new(0, 20, 0, 20) -- Larger for touch
                    toggleButton.AutoButtonColor = false
                    toggleButton.Font = Enum.Font.SourceSans
                    toggleButton.Text = ""
                    toggleButton.TextColor3 = Color3.fromRGB(0, 0, 0)
                    toggleButton.TextSize = 14.000
                    toggleButton.MouseButton1Click:Connect(function()
                        PerformToggle()
                    end)

                    togBtnCorner.CornerRadius = UDim.new(0, 50)
                    togBtnCorner.Name = "togFrameCorner"
                    togBtnCorner.Parent = toggleButton

                    Resize(38)
                end

                function elements:Slider(options)
                    if not options.text or not options.min or not options.max or not options.callback then Notify("Slider", "Missing arguments!") return end

                    local Slider = Instance.new("Frame")
                    local sliderLabel = Instance.new("TextLabel")
                    local sliderFrame = Instance.new("TextButton")
                    local sliderBall = Instance.new("TextButton")
                    local sliderBallCorner = Instance.new("UICorner")
                    local sliderTextBox = Instance.new("TextBox")
                    buttoneffect({frame = sliderLabel, entered = Slider})

                    local Value
                    local Held = false

                    local UIS = UserInputService -- Already defined globally
                    local RS = RunService -- Already defined globally
                    local Mouse = themouse -- Already defined globally

                    local percentage = 0
                    local step = options.step or 0.01 -- Added step option for finer control

                    local function snap(number, factor)
                        if factor == 0 then
                            return number
                        else
                            return math.floor(number/factor+0.5)*factor
                        end
                    end

                    UIS.InputEnded:Connect(function(inputObject)
                        -- Check if the input object is related to the slider drag
                        if inputObject.UserInputType == Enum.UserInputType.MouseButton1 or inputObject.UserInputType == Enum.UserInputType.Touch then
                            Held = false
                        end
                    end)

                    Slider.Name = "Slider"
                    Slider.Parent = sectionFrame
                    Slider.BackgroundColor3 = Color3.fromRGB(157, 171, 182)
                    Slider.BackgroundTransparency = 1.000
                    Slider.Size = UDim2.new(0.9, 0, 0, 35) -- 90% width, fixed height

                    sliderLabel.Name = "sliderLabel"
                    sliderLabel.Parent = Slider
                    sliderLabel.AnchorPoint = Vector2.new(0.5, 0.5)
                    sliderLabel.BackgroundColor3 = Color3.fromRGB(157, 171, 182)
                    sliderLabel.BackgroundTransparency = 1.000
                    sliderLabel.Position = UDim2.new(0.2, 0, 0.5, 0) -- Adjusted position
                    sliderLabel.Size = UDim2.new(0.5, 0, 1, 0) -- 50% width, full height of Slider
                    sliderLabel.Font = Enum.Font.Gotham
                    sliderLabel.Text = " " .. options.text
                    sliderLabel.TextColor3 = Color3.fromRGB(157, 171, 182)
                    sliderLabel.TextSize = 14.000
                    sliderLabel.TextXAlignment = Enum.TextXAlignment.Left
                    sliderLabel.TextScaled = true
                    sliderLabel.MinTextSize = 10
                    sliderLabel:GetPropertyChangedSignal("TextBounds"):Connect(function()
                        if sliderLabel.TextBounds.X > sliderLabel.AbsoluteSize.X * 0.9 then -- Check relative to own size
                            sliderLabel.TextScaled = true
                        else
                            sliderLabel.TextScaled = false
                        end
                    end)

                    sliderFrame.Name = "sliderFrame"
                    sliderFrame.Parent = sliderLabel
                    sliderFrame.BackgroundColor3 = Color3.fromRGB(29, 87, 118)
                    sliderFrame.BorderSizePixel = 0
                    sliderFrame.AnchorPoint = Vector2.new(0.5, 0.5)
                    sliderFrame.Position = UDim2.new(0.75, 0, 0.5, 0) -- Position right of label, scale based
                    sliderFrame.Size = UDim2.new(0.4, 0, 0, 2) -- 40% width of sliderLabel, fixed height for the bar
                    sliderFrame.Text = ""
                    sliderFrame.AutoButtonColor = false
                    sliderFrame.MouseButton1Down:Connect(function()
                        Held = true
                    end)
                    sliderFrame.TouchTap:Connect(function() -- Added TouchTap for mobile tapping
                        Held = true
                    end)


                    sliderBall.Name = "sliderBall"
                    sliderBall.Parent = sliderFrame
                    sliderBall.AnchorPoint = Vector2.new(0.5, 0.5)
                    sliderBall.BackgroundColor3 = Color3.fromRGB(67, 136, 231)
                    sliderBall.BorderSizePixel = 0
                    sliderBall.Position = UDim2.new(0, 0, 0.5, 0) -- Initial position
                    sliderBall.Size = UDim2.new(0, 20, 0, 20) -- Larger for touch
                    sliderBall.AutoButtonColor = false
                    sliderBall.Font = Enum.Font.SourceSans
                    sliderBall.Text = ""
                    sliderBall.TextColor3 = Color3.fromRGB(0, 0, 0)
                    sliderBall.TextSize = 14.000
                    sliderBall.MouseButton1Down:Connect(function()
                        Held = true
                    end)
                    sliderBall.TouchTap:Connect(function() -- Added TouchTap
                        Held = true
                    end)

                    RunService.RenderStepped:Connect(function()
                        if Held then
                            local mouseX = UserInputService:GetMouseLocation().X
                            local frameAbsoluteX = sliderFrame.AbsolutePosition.X
                            local frameAbsoluteWidth = sliderFrame.AbsoluteSize.X

                            local pos = math.clamp((mouseX - frameAbsoluteX) / frameAbsoluteWidth, 0, 1) -- Clamp between 0 and 1
                            percentage = snap(pos, step) -- Use the step for snapping

                            -- Calculate Value based on percentage, min, max
                            Value = options.min + (percentage * (options.max - options.min))
                            Value = round(Value, options.float or 1) -- Use options.float as bracket for rounding
                            -- No need to clamp here, as percentage is already clamped 0-1,
                            -- and Value will be within min-max range.
                            sliderTextBox.Text = tostring(Value) -- Convert to string
                            options.callback(Value)

                            sliderBall.Position = UDim2.new(percentage, 0, 0.5, 0) -- Update ball position
                        end
                    end)

                    sliderBallCorner.CornerRadius = UDim.new(0, 50)
                    sliderBallCorner.Name = "sliderBallCorner"
                    sliderBallCorner.Parent = sliderBall

                    sliderTextBox.Name = "sliderTextBox"
                    sliderTextBox.Parent = sliderLabel
                    sliderTextBox.BackgroundColor3 = Color3.fromRGB(1, 7, 17)
                    sliderTextBox.AnchorPoint = Vector2.new(0.5, 0.5)
                    sliderTextBox.Position = UDim2.new(1.1, 0, 0.5, 0) -- Position right of sliderFrame
                    sliderTextBox.Size = UDim2.new(0.3, 0, 0.8, 0) -- Scaled size
                    sliderTextBox.Font = Enum.Font.Gotham
                    sliderTextBox.Text = tostring(options.min) -- Set initial text
                    sliderTextBox.TextColor3 = Color3.fromRGB(234, 239, 245)
                    sliderTextBox.TextSize = 11.000
                    sliderTextBox.TextWrapped = true
                    sliderTextBox.TextScaled = true
                    sliderTextBox.MinTextSize = 8

                    sliderTextBox.Focused:Connect(function()
                        TweenService:Create(sliderLabel, TweenInfo.new(0.06, Enum.EasingStyle.Quart, Enum.EasingDirection.In), {TextColor3 = Color3.fromRGB(234, 239, 246)}):Play()
                    end)

                    sliderTextBox.FocusLost:Connect(function(Enter)
                        TweenService:Create(sliderLabel, TweenInfo.new(0.06, Enum.EasingStyle.Quart, Enum.EasingDirection.In), {TextColor3 = Color3.fromRGB(157, 171, 182)}):Play()
                        if Enter then
                            local enteredValue = tonumber(sliderTextBox.Text)
                            if enteredValue ~= nil then
                                if enteredValue > options.max then
                                    sliderTextBox.Text = tostring(options.max)
                                    options.callback(options.max)
                                elseif enteredValue < options.min then
                                    sliderTextBox.Text = tostring(options.min)
                                    options.callback(options.min)
                                else
                                    options.callback(enteredValue)
                                end
                            else
                                -- If text is not a valid number, revert to current value
                                sliderTextBox.Text = tostring(Value)
                            end
                        end
                    end)

                    Resize(38)
                end

                function elements:Dropdown(options)
                    if not options.text or not options.default or not options.list or not options.callback then Notify("Dropdown", "Missing arguments!") return end

                    local DropYSize = 0
                    local Dropped = false

                    local Dropdown = Instance.new("Frame")
                    local dropdownLabel = Instance.new("TextLabel")
                    local dropdownText = Instance.new("TextLabel")
                    local dropdownArrow = Instance.new("ImageButton")
                    local dropdownList = Instance.new("Frame")
                    local dropdownListCorner = Instance.new("UICorner") -- Added corner for dropdown list

                    local dropListLayout = Instance.new("UIListLayout")
                    buttoneffect({frame = dropdownLabel, entered = Dropdown})

                    Dropdown.Name = "Dropdown"
                    Dropdown.Parent = sectionFrame
                    Dropdown.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                    Dropdown.BackgroundTransparency = 1.000
                    Dropdown.BorderSizePixel = 0
                    Dropdown.Size = UDim2.new(0.9, 0, 0, 35) -- 90% width, fixed height for the main dropdown
                    Dropdown.ZIndex = 2

                    dropdownLabel.Name = "dropdownLabel"
                    dropdownLabel.Parent = Dropdown
                    dropdownLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                    dropdownLabel.BackgroundTransparency = 1.000
                    dropdownLabel.BorderSizePixel = 0
                    dropdownLabel.Size = UDim2.new(0.6, 0, 1, 0) -- 60% width, full height of Dropdown
                    dropdownLabel.Font = Enum.Font.Gotham
                    dropdownLabel.Text = " " .. options.text
                    dropdownLabel.TextColor3 = Color3.fromRGB(157, 171, 182)
                    dropdownLabel.TextSize = 14.000
                    dropdownLabel.TextXAlignment = Enum.TextXAlignment.Left
                    dropdownLabel.TextScaled = true
                    dropdownLabel.MinTextSize = 10

                    dropdownText.Name = "dropdownText"
                    dropdownText.Parent = Dropdown
                    dropdownText.BackgroundColor3 = Color3.fromRGB(1, 7, 17)
                    dropdownText.BorderSizePixel = 0
                    dropdownText.AnchorPoint = Vector2.new(1, 0.5) -- Anchor to right middle
                    dropdownText.Position = UDim2.new(0.95, 0, 0.5, 0) -- 95% from left, centered vertically
                    dropdownText.Size = UDim2.new(0.35, 0, 0.8, 0) -- 35% width, 80% height of Dropdown
                    dropdownText.Font = Enum.Font.Gotham
                    dropdownText.Text = options.default
                    dropdownText.TextColor3 = Color3.fromRGB(234, 239, 245)
                    dropdownText.TextSize = 12.000
                    dropdownText.TextWrapped = true
                    dropdownText.TextScaled = true
                    dropdownText.MinTextSize = 8
                    dropdownText.TextXAlignment = Enum.TextXAlignment.Right

                    dropdownArrow.Name = "dropdownArrow"
                    dropdownArrow.Parent = Dropdown
                    dropdownArrow.BackgroundColor3 = Color3.fromRGB(234, 239, 245)
                    dropdownArrow.BackgroundTransparency = 1.000
                    dropdownArrow.BorderSizePixel = 0
                    dropdownArrow.AnchorPoint = Vector2.new(0.5, 0.5)
                    dropdownArrow.Position = UDim2.new(0.95, 0, 0.5, 0) -- Position adjusted
                    dropdownArrow.Size = UDim2.new(0, 16, 0, 16) -- Fixed size for arrow
                    dropdownArrow.Image = "rbxassetid://7999863454" -- Example arrow image
                    dropdownArrow.ImageColor3 = Color3.fromRGB(132, 146, 153)
                    dropdownArrow.ZIndex = 3

                    -- Dropdown List Setup
                    dropdownList.Name = "dropdownList"
                    dropdownList.Parent = Dropdown
                    dropdownList.BackgroundColor3 = Color3.fromRGB(13, 28, 44)
                    dropdownList.BorderSizePixel = 0
                    dropdownList.Position = UDim2.new(0, 0, 1, 0) -- Below the main dropdown
                    dropdownList.Size = UDim2.new(1, 0, 0, 0) -- Start with 0 height, expand later
                    dropdownList.ClipsDescendants = true
                    dropdownList.ZIndex = 1 -- Behind the main dropdown until opened
                    dropdownList.Visible = false -- Start hidden

                    dropdownListCorner.CornerRadius = UDim.new(0, 4)
                    dropdownListCorner.Name = "dropdownListCorner"
                    dropdownListCorner.Parent = dropdownList

                    dropListLayout.Name = "dropListLayout"
                    dropListLayout.Parent = dropdownList
                    dropListLayout.SortOrder = Enum.SortOrder.LayoutOrder
                    dropListLayout.Padding = UDim.new(0, 2) -- Small padding

                    -- Populate dropdown list
                    for i, listItem in ipairs(options.list) do
                        local itemButton = Instance.new("TextButton")
                        itemButton.Parent = dropdownList
                        itemButton.BackgroundColor3 = Color3.fromRGB(13, 28, 44)
                        itemButton.BackgroundTransparency = 1
                        itemButton.Size = UDim2.new(1, 0, 0, 25) -- Full width, fixed height for each item (touch friendly)
                        itemButton.Font = Enum.Font.Gotham
                        itemButton.Text = listItem
                        itemButton.TextColor3 = Color3.fromRGB(157, 171, 182)
                        itemButton.TextSize = 14.000
                        itemButton.TextXAlignment = Enum.TextXAlignment.Left
                        itemButton.TextScaled = true
                        itemButton.MinTextSize = 10
                        buttoneffect({frame = itemButton, entered = itemButton})
                        clickEffect({button = itemButton, amount = 2}) -- Smaller click effect for items

                        itemButton.MouseButton1Click:Connect(function()
                            dropdownText.Text = listItem
                            options.callback(listItem)
                            -- Close dropdown after selection
                            TweenService:Create(dropdownList, TweenInfo.new(0.2, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {
                                Size = UDim2.new(1, 0, 0, 0)
                            }):Play()
                            Dropped = false
                            dropdownList.Visible = false
                            Resize(-DropYSize) -- Shrink section
                            DropYSize = 0
                        end)

                        DropYSize += itemButton.Size.Y.Offset + dropListLayout.Padding.Offset -- Accumulate height
                    end

                    Dropdown.MouseButton1Click:Connect(function()
                        Dropped = not Dropped
                        dropdownList.Visible = true -- Make visible before tweening

                        local targetHeight = Dropped and DropYSize or 0
                        local tweenInfo = TweenInfo.new(0.2, Enum.EasingStyle.Quart, Enum.EasingDirection.Out)

                        TweenService:Create(dropdownList, tweenInfo, {
                            Size = UDim2.new(1, 0, 0, targetHeight)
                        }):Play()

                        if Dropped then
                            Resize(DropYSize) -- Expand section to fit dropdown
                            dropdownList.ZIndex = 4 -- Bring to front when open
                        else
                            Resize(-DropYSize) -- Shrink section
                            -- Wait for tween to finish before hiding
                            task.wait(tweenInfo.Time)
                            dropdownList.Visible = false
                            dropdownList.ZIndex = 1
                        end
                    end)

                    Resize(38) -- Initial resize for the dropdown itself
                end

                return elements
            end

            return sections
        end

        return tabs
    end

    return tabsections
end

return Library
